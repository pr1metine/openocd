#!/usr/bin/env python

import os
import ntpath
import sys
try:
     from elftools.elf.elffile import ELFFile
except ImportError:
     print "You don't seem to have 'elftools' package installed. Use pip or easy_install to do so"

helper_exported_buffers = [
     'outbuffer'
]

helper_exported_functions = [
     "f0xx_do_perf_counting",
     "f0xx_erase_sectors",
     "f0xx_write_block",
]

namespace = 'tms570ls31'

output = sys.stdout

def emit_function_entry_point(stream, namespace, name, address):
     stream.write("static const uint32_t %s_%s = 0x%08x;\n" % (namespace, name, address & 0xFFFFFFFFE))

def emit_buffer_entry(stream, namespace, name, address, size):
     stream.write("static const uint32_t %s_%s_offset = 0x%08x;\n" % (namespace, name, address))
     stream.write("static const uint32_t %s_%s_size   = 0x%08x;\n" % (namespace, name, size))

def emit_binary_blob(stream, namespace, name, blob):
     stream.write("static const uint8_t %s_%s[] = {\n" % (namespace, name))
     i = 0
     l = len(blob) - 1
     for i, byte in enumerate(blob):
          if (i) % 16 == 0:
               stream.write("\t")

          if (i + 1) % 16 == 0 or i == l:
               stream.write("0x%02x,\n" % ord(byte))
          else:
               stream.write("0x%02x, " % ord(byte))

     if (i + 1) % 16 != 0:
               stream.write("\n")

     stream.write("};\n");

def emit_section_parmeters(stream, namespace, name, section):
     stream.write("static const uint32_t %s_%s_offset = 0x%08x;\n" % (namespace, name, section.header['sh_addr']))
     stream.write("static const uint32_t %s_%s_size   = %d;\n"     % (namespace, name, section.header['sh_size']))

if __name__ == '__main__':
     elf_filename = sys.argv[1]

     head, tail = ntpath.split(elf_filename)
     namespace  = os.path.splitext(ntpath.basename(tail))[0].replace("-", "_")

     with open(elf_filename, 'rb') as elf_file:
          executable = ELFFile(elf_file)

          output.write("/***************************************************************************\n")
          output.write(" *                     WARNING! WARNING! WARNING!                          *\n")
          output.write(" * This file is autogenerated using 'elf-to-h' script, do not edit it      *\n")
          output.write(" * manually!                                                               *\n")
          output.write(" *                     WARNING! WARNING! WARNING!                          *\n")
          output.write("***************************************************************************/\n")
          output.write("#ifndef __%s_H__\n" % namespace.upper())
          output.write("#define __%s_H__\n" % namespace.upper())
          output.write("\n")

          bss  = executable.get_section_by_name(b'.bss')
          if bss:
               emit_section_parmeters(output, namespace, "bss", bss)
               output.write("\n")

          data  = executable.get_section_by_name(b'.data')
          if bss:
               emit_section_parmeters(output, namespace, "data", data)
               output.write("\n")

          emit_binary_blob(output, namespace, "data", data.data())
          output.write("\n")

          text = executable.get_section_by_name(b'.text')
          emit_section_parmeters(output, namespace, "text", text)
          output.write("\n")

          emit_binary_blob(output, namespace, "text", text.data())
          output.write("\n")

          symbols = executable.get_section_by_name(b'.symtab')
          for sym in symbols.iter_symbols():
               if sym.name in helper_exported_buffers:
                    emit_buffer_entry(output, namespace, sym.name, sym.entry['st_value'], sym.entry['st_size'])
               elif sym.name in helper_exported_functions:
                    emit_function_entry_point(output, namespace, sym.name, sym.entry['st_value'])

          output.write("\n")
          output.write("#endif\n")
